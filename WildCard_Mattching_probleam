//wild card probleam
Covers Both Recursive And Tabulated part.
class Solution {
    public boolean isMatch(String s, String p) {
        boolean dp[][] = new boolean[p.length()+1][s.length()+1];
        for(boolean row[] : dp)
            Arrays.fill(row,false);
        int m = s.length();
        int n = p.length();
        dp[0][0] = true;
        for(int j =1;j<=m;j++){
            dp[0][j] = false;
        }
        for(int j = 1;j<=n;j++){
            boolean f = true;
            for(int ii=1;ii<=j;ii++){
               if(p.charAt(ii-1)!='*') f = false;
           }
            dp[j][0] = f;
        }
        for(int i =1;i<=n;i++){
            for(int j =1;j<=m;j++){
                if(p.charAt(i-1)==s.charAt(j-1)||p.charAt(i-1)=='?'){
            dp[i][j]=dp[i-1][j-1];
       }
       else if(p.charAt(i-1)=='*')
        dp[i][j]=dp[i-1][j]||dp[i][j-1];

          else dp[i][j]=false;
            }
        }
        return dp[n][m];
       // return rec(p.length()-1,s.length()-1,s,p,dp);
    }
    // recursive part memoization provides you TLE so avoid using memoization....
   /* public static boolean rec(int i,int j,String s,String p, boolean dp[][]){
        if(i<0&&j>=0)
            return false;
        if(i<0&&j<0)
        return true;
       if(i>=0&&j<0){
           for(int ii=0;ii<=i;ii++){
               if(p.charAt(ii)!='*') return false;
           }
            return true;
       }
       if(dp[i][j]==true) return dp[i][j];
       if(p.charAt(i)==s.charAt(j)||p.charAt(i)=='?'){
           return dp[i][j]=rec(i-1,j-1,s,p,dp);
       }
       if(p.charAt(i)=='*')
       return dp[i][j]=rec(i-1,j,s,p,dp)||rec(i,j-1,s,p,dp);

       return dp[i][j]=false;
    }
    */
}
